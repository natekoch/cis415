#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>


int main () {

    freopen("output.txt", "w+", stdout);


    // -------------------------------
    // Using fopen ----------- DO NOT USE fopen in command.c file in project
    char *buf = NULL;
    size_t len = 0;

    FILE *inputFile = fopen("reopen_read.c", "r");

    while(getline(&buf, &len, inputFile) != -1)
    {
        write(1, buf, strlen(buf));
    }
    fclose(inputFile);
    free(buf);


    // -------------------------------
    // Using read ---- alternative to open --- using system call
    int     fd_read, fd_write, fd_read_again;
    char    line_buf[1024];
    ssize_t  count;
    fd_read = open("reopen_read.c", O_RDONLY);

    while ((count = read(fd_read, line_buf, 1024)) > 0)
    {
        // write to stdout
        write(1, line_buf, count);
    }
    close(fd_read);

    // -------------------------------
    // Lets grab the errof if file does not exists ----- no_file.c does not exist
    fd_read_again = open("no_file.c", O_RDONLY);
    // See how we could grad the error generated by system calls
    if (fd_read_again == -1)
        write(1, strerror(errno), strlen(strerror(errno)));

    close(fd_read_again);

    //    copyfile basic implementation
    fd_read_again = open("reopen_read.c", O_RDONLY);
    fd_write = open("new_reopen_read.c", O_CREAT | O_WRONLY, 0666);

    while ((count = read(fd_read_again, line_buf,  1024)) > 0) {
        write(fd_write, line_buf, count);
        write(1, strerror(errno), strlen(strerror(errno)));
    }

    close(fd_read_again);
    close(fd_write);

    return(0);
}